// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  uid              String       @id @default(cuid()) @map("id")
  username         String       @unique
  email            String       @unique
  password         String
  name             String?
  bio              String?
  photoURL         String?
  gender           Gender?
  birthday         DateTime?
  subscription     Subscription @default(free)
  nextBillingDate  DateTime?
  hasBlueCheck     Boolean      @default(false)
  privacy          Json?
  hasVerifiedEmail Boolean      @default(false)
  isBlocked        Boolean      @default(false)
  isRestricted     Boolean      @default(false)
  credits          Int          @default(0) // Credits in centavos/cents
  federatedDiscoverable Boolean  @default(true) // Allow discovery in fediverse
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  posts          Post[]
  comments       Comment[]
  likes          Like[]
  commentLikes   CommentLike[]
  followers      Follow[]        @relation("followers")
  following      Follow[]        @relation("following")
  credentials    Credential[]
  sessions       Session[]
  reports        Report[]
  blockedBy      Block[]         @relation("BlockedBy")
  blocking       Block[]         @relation("Blocking")
  paymentMethods PaymentMethod[]
  adCampaigns    AdCampaign[]
  userKeys       UserKeys?
  federatedFollows FederatedFollow[]
  pollVotes      PollVote[]
  oAuthApplications OAuthApplication[]
  oAuthAuthorizationCodes OAuthAuthorizationCode[]
  oAuthAccessTokens OAuthAccessToken[]
}

model Post {
  id           String   @id @default(cuid())
  content      String?
  imageUrls    String[]
  liveVideoUrl String?
  postType     PostType @default(text)
  privacy      Privacy  @default(public)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  author    User           @relation(fields: [authorId], references: [uid])
  authorId  String
  comments  Comment[]
  likes     Like[]
  analytics PostAnalytics?
  mentions  Mention[]
  hashtags  Hashtag[]
  federatedLikes FederatedLike[]
  poll      Poll?
}

enum PostType {
  text
  live_video
  poll
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  parentId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post   Post          @relation(fields: [postId], references: [id])
  postId String
  author   User          @relation(fields: [authorId], references: [uid])
  authorId String
  parent   Comment?      @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[]     @relation("CommentReplies")
  likes    CommentLike[]
  mentions Mention[]
  hashtags Hashtag[]
}

model Like {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  post   Post   @relation(fields: [postId], references: [id])
  postId String
  user   User   @relation(fields: [userId], references: [uid])
  userId String
}

model Follow {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  follower    User   @relation("following", fields: [followerId], references: [uid])
  followerId  String
  following   User   @relation("followers", fields: [followingId], references: [uid])
  followingId String
}

model Credential {
  id           String   @id @default(cuid())
  userId       String
  provider     String
  passwordHash String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [uid])

  @@unique([userId, provider])
}

model Email {
  verificationId String   @id @db.VarChar(50)
  email          String
  code           String   @db.VarChar(10)
  expireAt       DateTime

  @@map("emails")
}

model PasswordReset {
  resetId  String   @id @db.VarChar(50)
  email    String
  code     String   @db.VarChar(10)
  expireAt DateTime
  createdAt DateTime @default(now())

  @@map("password_resets")
}

enum Subscription {
  free
  premium
  pro
}

model PostAnalytics {
  id        String   @id @default(cuid())
  postId    String   @unique
  views     Int      @default(0)
  shares    Int      @default(0)
  clicks    Int      @default(0)
  earnings  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post Post @relation(fields: [postId], references: [id])
}

enum Privacy {
  public
  private
  followers
}

model Session {
  id        String   @id @default(cuid())
  sid       String   @unique
  userId    String?
  ipAddress String?
  location  String?
  data      Json
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User? @relation(fields: [userId], references: [uid])
}

model Report {
  id          String       @id @default(cuid())
  reporterId  String
  targetType  ReportType
  targetId    String
  reason      ReportReason
  description String?
  status      ReportStatus @default(pending)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  reporter User @relation(fields: [reporterId], references: [uid])

  @@unique([reporterId, targetType, targetId])
}

model Block {
  id        String       @id @default(cuid())
  blockerId String
  blockedId String
  reason    BlockReason?
  createdAt DateTime     @default(now())

  blocker User @relation("BlockedBy", fields: [blockerId], references: [uid])
  blocked User @relation("Blocking", fields: [blockedId], references: [uid])

  @@unique([blockerId, blockedId])
}

model PaymentMethod {
  id                    String          @id @default(cuid())
  userId                String
  type                  PaymentType
  provider              PaymentProvider @default(paypal)
  paypalPaymentMethodId String          @unique
  last4                 String?
  expiryMonth           Int?
  expiryYear            Int?
  holderName            String?
  phoneNumber           String?
  paypalEmail           String?
  isDefault             Boolean         @default(false)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  user User @relation(fields: [userId], references: [uid])
}

model CommentLike {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id])
  user    User    @relation(fields: [userId], references: [uid])

  @@unique([commentId, userId])
}

model Mention {
  id        String   @id @default(cuid())
  postId    String?
  commentId String?
  username  String
  createdAt DateTime @default(now())

  post    Post?    @relation(fields: [postId], references: [id])
  comment Comment? @relation(fields: [commentId], references: [id])
}

model Hashtag {
  id        String   @id @default(cuid())
  postId    String?
  commentId String?
  tag       String
  createdAt DateTime @default(now())

  post    Post?    @relation(fields: [postId], references: [id])
  comment Comment? @relation(fields: [commentId], references: [id])

  @@index([tag])
}

enum ReportType {
  post
  comment
  user
}

enum ReportReason {
  spam
  harassment
  hate_speech
  inappropriate_content
  copyright
  other
}

enum ReportStatus {
  pending
  reviewed
  resolved
  dismissed
}

enum BlockReason {
  harassment
  spam
  inappropriate_content
  other
}

enum PaymentType {
  paypal_card
  paypal_wallet
}

enum PaymentProvider {
  paypal
}

enum Gender {
  male
  female
  non_binary
  prefer_not_to_say
}

model AdCampaign {
  id             String       @id @default(cuid())
  title          String
  description    String?
  targetType     AdTargetType
  targetId       String?
  budget         Int // Budget in cents
  spent          Int          @default(0) // Amount spent in cents
  earnings       Int          @default(0) // Earnings in cents
  duration       Int // Duration in days
  targetAudience Json?
  adType         AdType       @default(promotion)
  status         AdStatus     @default(pending)
  advertiserId   String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  startDate      DateTime?
  endDate        DateTime?

  advertiser User         @relation(fields: [advertiserId], references: [uid])
  analytics  AdAnalytics?
}

model AdAnalytics {
  id          String   @id @default(cuid())
  campaignId  String   @unique
  impressions Int      @default(0)
  clicks      Int      @default(0)
  conversions Int      @default(0)
  reach       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  campaign AdCampaign @relation(fields: [campaignId], references: [id])
}

enum AdTargetType {
  post
  profile
  hashtag
  general
}

enum AdType {
  promotion
  sponsored
  banner
  video
}

enum AdStatus {
  pending
  active
  paused
  completed
  rejected
}

model UserKeys {
  id         String @id @default(cuid())
  userId     String @unique
  publicKey  String @db.Text
  privateKey String @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [uid], onDelete: Cascade)
}

model FederatedFollow {
  id          String @id @default(cuid())
  actorUrl    String
  followingId String
  activityId  String
  createdAt   DateTime @default(now())

  following User @relation(fields: [followingId], references: [uid], onDelete: Cascade)

  @@unique([actorUrl, activityId])
}

model FederatedLike {
  id         String @id @default(cuid())
  postId     String
  actorUrl   String
  activityId String
  createdAt  DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([postId, actorUrl])
}

model FederatedPost {
  id         String @id @default(cuid())
  actorUrl   String
  content    String @db.Text
  activityId String @unique
  published  DateTime
  createdAt  DateTime @default(now())
}

model Poll {
  id          String   @id @default(cuid())
  postId      String   @unique
  question    String
  expiresAt   DateTime?
  allowMultiple Boolean @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  post    Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  options PollOption[]
  votes   PollVote[]
}

model PollOption {
  id       String @id @default(cuid())
  pollId   String
  text     String
  position Int
  createdAt DateTime @default(now())

  poll  Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes PollVote[]

  @@unique([pollId, position])
}

model PollVote {
  id         String @id @default(cuid())
  pollId     String
  optionId   String
  userId     String?
  actorUrl   String? // For federated votes
  activityId String? // For federated activities
  createdAt  DateTime @default(now())

  poll   Poll        @relation(fields: [pollId], references: [id], onDelete: Cascade)
  option PollOption  @relation(fields: [optionId], references: [id], onDelete: Cascade)
  user   User?       @relation(fields: [userId], references: [uid], onDelete: Cascade)

  @@unique([pollId, userId])
  @@unique([pollId, actorUrl])
}

model OAuthApplication {
  id           String @id @default(cuid())
  name         String
  clientId     String @unique
  clientSecret String
  redirectUris String[]
  scopes       String
  website      String?
  userId       String? // Optional: for user-created apps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user                User?                    @relation(fields: [userId], references: [uid], onDelete: Cascade)
  authorizationCodes  OAuthAuthorizationCode[]
  accessTokens        OAuthAccessToken[]
}

model OAuthAuthorizationCode {
  id                    String @id @default(cuid())
  code                  String @unique
  applicationId         String
  userId                String
  redirectUri           String
  scope                 String
  codeChallenge         String?
  codeChallengeMethod   String?
  expiresAt             DateTime
  createdAt             DateTime @default(now())

  application OAuthApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  user        User             @relation(fields: [userId], references: [uid], onDelete: Cascade)
}

model OAuthAccessToken {
  id            String @id @default(cuid())
  token         String @unique
  refreshToken  String?
  applicationId String
  userId        String
  scope         String
  expiresAt     DateTime
  createdAt     DateTime @default(now())

  application OAuthApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  user        User             @relation(fields: [userId], references: [uid], onDelete: Cascade)
}